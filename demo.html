<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<script >
window.log = console.log.bind(console)

class Vertex {
    constructor(label) {
        this.label = label;
    }
};

class Graph {
    constructor(v) {
        this.vertices = v;
        this.vertexList = [];
        this.edges = 0;
        this.edgeTo = []; // 保存从一个顶点到下一个顶点的所有边
        this.adj = [];
        this.marked = [];
        for(let i = 0; i < this.vertices; i++) {
            this.adj[i] = [];
            this.marked[i] = false;
        };
    }
    topSort() {
        const stack = [];
        const visited = [];
        for (let i = 0; i < this.vertices; i++) {
            visited[i] = false;
        };
        for (let i = 0; i < this.vertices; i++) {
            if (visited[i] == false) {
                this.topSortHelper(i, visited, stack);
            }
        };
        for (let i = stack.length - 1; i >= 0; i--) {
            log(this.vertexList[stack[i]])
        };
    }
    topSortHelper(v, visited, stack) {
        visited[v] = true;

        (this.adj[v] || []).forEach(w => {
            if (!visited[w]) {
                this.topSortHelper(w, visited, stack)
            }
        });
        stack.push(v)
    }
    addEdge(v, w) {
        this.adj[v].push(w);
        this.adj[w].push(v);
        this.edges++;
    }
    showGraph() {
        var visited = [];
        for (let i = 0; i < this.vertices; i++) {
            let str = this.vertexList[i] + '-->';
            visited.push(this.vertexList[i]);
            for (let j = 0; j < this.vertices; j++) {
                if (this.adj[i][j] != undefined) {
                    if (visited.indexOf(this.vertexList[j]) < 0) {
                        str += this.vertexList[j] + ' ';
                    }
                }
            };
            visited.pop();
            log(str)
        };
        log(' ');
    }
    // 深度优先算法
    dfs(v) {
        this.marked[v] = true;
        if (this.adj[v] != undefined) {
            log('哪些点可以到达: ' + v);
        };
        (this.adj[v] || []).forEach(i => {
            if(!this.marked[i]) {
                this.dfs(i)
            }
        })
    }
    // 广度优先算法
    bfs(s) {
        const queue = [];
        this.marked[s] = true;
        queue.push(s); // 添加至队尾
        while (queue.length) {
            const v = queue.shift(); // 从队首删除
            if (this.adj[v] != undefined) {
                log('哪些点可以到达: ' + v);
            };
            (this.adj[v] || []).forEach(i => {
                if(!this.marked[i]) {
                    this.edgeTo[i] = v;
                    this.marked[i] = true;
                    queue.push(i);
                }
            })
        }
    }
    // 创建一个栈 存储于指定顶点有共同边的所有顶点
    pathTo(v) {
        const source = 0;
        if (!this.hasPathTo(v)) {
            return undefined;
        };

        const path = [];
        for (let i = v; i != source; i = this.edgeTo[i]) {
            path.push(i);
        };
        path.push(source);
        return path;
    }
    hasPathTo(v) {
        return this.marked[v];
    }
};

const g = new Graph(6);
g.addEdge(1, 2);
g.addEdge(2, 5);
g.addEdge(1, 3);
g.addEdge(1, 4);
g.addEdge(0, 1);
g.vertexList = [ 'CS1', 'CS2', '数据结构', '汇编语言', '操作系统', '算法' ];
g.showGraph();
g.topSort();
</script>
<body>
    
</body>
</html>