> 算数表达式在编程中分为: **前缀表达式**, **中缀表达式**以及 **后缀表达式**. 他们之间的区别在于运算符相对于操作数的位置不同: 前缀表达式的运算符位于与其相关的操作数之前; 中缀和后缀同理.

栗子:
`(3 + 4) × 5 - 6` 中缀表达式
`- × + 3 4 5 6` 前缀表达式
`3 4 + 5 × 6 -` 后缀表达式

## 中缀表达式
是一种通用的算数或逻辑公式表示方法, 操作符以中缀形式处于操作数的中间. 中缀表达式是人们常用的算数表示方法. 虽然人的大脑很容易理解与分析中缀表达式, 但对于计算机来说中缀表达式却是很复杂的, 因此计算表达式的值时, 通常需要先将中缀表达式转化为前缀或后缀表达式, 然后进行求值. 
对计算机来说, 计算前缀或后缀表达式的值非常简单.

## 前缀表达式
前缀表达式的运算符位于操作数之前.

### 前缀表达式的求值
从右至左扫描表达式, 遇到数字时, 将数字入栈, 遇到运算符时, 弹出栈顶的两个数, 用运算符与他们做相应的计算 (栈顶元素 op 次顶元素), 并将结果入栈; 重复上述过程直到表达式最左端, 最后运算得出的值即为表达式的结果.
计算 _栗子_ 中的前缀表达式:
1. 从左至右扫描, 将`6`, `5`, `4`, `3`入栈;
2. 遇到`+`运算符, 因此弹出`3`和`4`(`3`为栈顶元素, `4`为次顶元素, 注意与后缀表达式作比较), 计算出`3 + 4`的值, 然后将结果`7`再入栈;
3. 接下来是`*`运算符, 因此弹出`7`和`5`, 计算出`7 * 5 = 35`, 再将`35`入栈;
4. 最后是`-`运算符, 弹出`35`和`6`, 计算`35 - 6`得出最终结果`29`;

### 中缀表达式转化前缀表达式:
遵循以下步骤:
1. 初始化两个栈: 运算符栈`S1`和存储中间结果的栈`S2`;
2. 从左至右扫描中缀表达式;
3. 遇到操作数时, 将其压入`S2`;
4. 遇到运算符时, 比较其与`S1`栈顶运算符的优先级
    1. `S1`若为空, 或栈顶运算符为右括号`)`, 则直接将此运算符入栈;
    2. 否则, 若优先级比栈顶运算符的较高或相等, 也将运算符压入`S1`;
    3. 否则, 将`S1`栈顶的运算符弹出并压入到`S2`中, 再次转到 _4.1_ 与`S1`中的新栈顶运算符相比较;
5. 遇到括号时:
    1. 如果是右括号`)`, 则直接压入`S1`;
    2. 如果是左括号`(`, 则依次弹出`S1`栈顶的运算符, 并压入`S2`, 直到遇到右括号`)`为止, 此时将这一对括号丢弃;
6. 重复步骤 _2_ 至 _5_ , 知道表达式的最左边;
7. 将`S1`中剩余的运算符依次弹出并压入`S2`;
8. 依次弹出`S2`中的元素并输出, 结果即为中缀表达式对应的前缀表达式.

eg: 将中缀表达式`1+((2+3)×4)-5`转换为前缀表达式的过程如下:
| 扫描到的元素 | `S2`(栈底 -> 栈顶) | `S1`(栈底 -> 栈顶) | 说明 |
| :-- | :-- | :-- | :-- |
| 5 | 5 | 空 | 数字, 直接入栈`S2` |
| - | 5 | - | `S1`为空, 运算符直接入栈`S1` |
| ) | 5 | - ) | 右括号直接入栈`S1` |
| 4 | 5 4 | - ) | 数字直接入栈`S2` |
| * | 5 4 | - ) * | `S1`栈顶是右括号, 直接入栈`S1` |
| ) | 5 4 | - ) * ) | 右括号直接入栈`S1` |
| 3 | 5 4 3 | - ) * ) | 数字直接入栈`S2` |
| + | 5 4 3 | - ) * ) + | `S1`栈顶为右括号直接入栈`S1` |
| 2 | 5 4 3 2 | - ) * ) + | 数字直接入栈`S2` |
| ( | 5 4 3 2 + | - ) * | 左括号, 弹出`S1`运算符直至遇到右括号 |
| ( | 5 4 3 2 + * | - | 同上 |
| + | 5 4 3 2 + * | - + | 优先级与`-`相同, 入栈`S1` |
| 1 | 5 4 3 2 + * 1 | - + | 数字直接入栈`S2` |
| 到达最左端 | 5 4 3 2 + * 1 + - | 空 | `S1`依次出栈 入栈`S2` |
得到结果`- + 1 * + 2 3 4 5`.

## 后缀表达式
后缀表达式与前缀表达式类似, 只是运算符位于操作数之后.

### 后缀表达式的求值
与前缀表达式类似, 只是顺序从左至右: 从左至右扫描表达式, 遇到数字时, 将数字入栈. 遇到运算符时, 弹出栈顶的两个数, 用运算符对它们做相应的计算 (次顶元素 op 栈顶元素), 并将结果入栈; 重复上述过程直到表达式最右端, 最后运算得出的值即为表达式的结果.

eg: 后缀表达式`3 4 + 5 * 6 -`
1. 从左至右扫描, 将`3`和`4`入栈;
2. 遇到`+`运算符, 弹出`4`和`3`(`4`为栈顶元素, `3`为次顶元素, 注意与前缀表达式作比较), 计算`3 + 4`将结果`7`入栈;
3. 将`5`入栈;
4. 接下来是`*`运算符, 因此弹出`5`和`7`, 计算`7 * 5`将结果`35`入栈;
5. 将`6`入栈;
6. 最后是`-`运算符, 计算`35 - 6`得出最终结果`29`;

### 中缀表达式转换后缀表达式
与转换前缀表达式相似, 遵循以下步骤:
1. 初始化两个栈: 运算符栈`S1`和存储中介结果的栈`S2`;
2. 从左至右扫描中缀表达式;
3. 遇到操作数, 压入`S2`;
4. 遇到运算符, 比较其与`S1`栈顶运算符的优先级:
    1. 如果`S1`为空或栈顶运算符为左括号`(`, 则直接将此运算符入栈`S1`;
    2. 否则, 若优先级比栈顶运算符的高, 也将运算符压入`S1` (注意转换为前端表达式时是优先级较高或相同, 而这里则是不包括相同的情况);
    3. 否则, 将`S1`栈顶的运算符弹出并压入`S2`中, 再次转到 _4.1_ 与`S1`中新的栈顶运算符相比较;
5. 遇到括号时:
    1. 如果是左括号`(`, 则直接压入`S1`;
    2. 如果是右括号`)`, 则依次弹出`S1`栈顶的运算符, 并压入`S2`, 直至遇到左括号, 此时将这一对括号丢弃;
6. 重复步骤 _2_ 至 _5_ , 知道表达式的最右边;
7. 将`S1`中剩余的运算符依次弹出并压入`S2`;
8. 依次弹出`S2`中的元素并输出, 结果是逆序即为中缀表达式对应的后缀表达式 (注意: 转换前缀表达式时不用逆序);

eg: 将中缀表达式`1+((2+3)×4)-5`转换为后缀表达式的过程如下
| 扫描到的元素 | `S2`(栈底 -> 栈顶) | `S1`(栈底 -> 栈顶) | 说明 |
| :-- | :-- | :-- | :-- |
| 1 | 1 | 空 | 数字直接入`S2` |
| + | 1 | + | `S1`为空直接入栈 |
| ( | 1 | + ( | 左括号直接入`S1` |
| ( | 1 | + ( ( | 同上 |
| 2 | 1 2 | + ( ( | 数字直接入栈`S2` |
| + | 1 2 | + ( ( + | 栈顶为左括号 直接入栈`S1` |
| 3 | 1 2 3 | + ( ( + | 数字 直接入栈`S2` |
| ) | 1 2 3 + | + ( | 右括号, 弹出运算符直至遇到左括号 |
| * | 1 2 3 + | + ( * | 栈顶为左括号 直接入栈`S1` |
| 4 | 1 2 3 + 4 | + ( * | 数字 直接入栈`S2` |
| ) | 1 2 3 + 4 * | + | 右括号, 弹出运算符直至遇到左括号 |
| - | 1 2 3 + 4 * + | - | `-`与`+`优先级相同, `S1`弹出`+`, 再压入`-` |
| 5 | 1 2 3 + 4 * + 5 | - | 数字 直接入栈`S2` |
| 到达最右端 | 1 2 3 + 4 * + 5 - | 空 | 弹出剩余`S1`中运算符 压入`S2` |
得到结果`1 2 3 + 4 * + 5 -`. (注意: 需要逆序输出).
